# 📜 instruction.md

## 1. Mumei の役割と存在意義

Mumeiは、AIエージェントが「推論」の結果として出力する不確かなコードを、数学的に「検証済み」の確実な資産へと変換するためのプロトコルである。
開発者は、ロジックを書く前に**不変の真理（requires/ensures）**を定義しなければならない。

---

## 2. 構文規則 (Syntactic Rules)

### 2.1 Atom の基本構造

すべてのロジックは `atom` 単位で記述する。

* **requires**: 実行前に満たされるべき条件。
* **ensures**: 実行後に保証されるべき結果。
* **body**: アルゴリズムの実装。`{}` によるブロック構文と `let` による変数定義を推奨する。

### 2.2 制御構文の鉄則

* **if-else**: 必ず `else` ブロックを含めること（数学的全域性の確保）。
* **let**: 変数は再代入不可（イミュータブル）として扱うこと。
* **ブロック末尾**: ブロック `{ ... }` の最後の式がそのブロックの評価値となる。

---

## 3. 鍛造ガイドライン (Forging Guidelines)

### 3.1 ゼロ除算の徹底排除

除算を行う場合は、必ず `requires` で分母が非ゼロであることを明示するか、`if` 文による動的なガードを実装せよ。

> **Bad**: `body: a / b;`
> **Good**: `body: if b != 0 { a / b } else { 0 };`

### 3.2 量子化子の活用

配列や範囲を扱う際は、`forall`（すべての要素が〜）を用いて境界条件を定義せよ。
例: `requires: forall(i, 0, len, arr[i] > 0);`

---

## 4. 検証失敗時の振る舞い (Self-Healing Protocol)

検証が `Failed` となった場合、開発者（またはAIエージェント）は以下の手順を踏むこと。

1. **反例 (Counter-example) の確認**: ビジュアライザーまたは `report.json` を参照し、どの入力値で論理が破綻したかを特定する。
2. **requires の強化**: 入力値の制約が緩すぎないか検討する。
3. **body の修正**: `if` ガードの追加や、エッジケースの処理を実装する。
4. **再鍛造**: 修正後、再び `cargo run` を実行し、数学的な矛盾が解消されたか確認する。

---

## 5. 言語出力の特性 (Output Semantics)

Mumei から出力されたコードは以下の特性を持つことを理解して利用すること。

| 言語 | 特徴 | 用途 |
| --- | --- | --- |
| **LLVM IR** | 高速・ネイティブ実行 | パフォーマンス重視のコアロジック |
| **Rust** | 所有権・型安全 | 高信頼性システムへの統合 |
| **Go** | シンプル・並行性 | マイクロサービス、バックエンド |
| **TypeScript** | 柔軟・Web親和性 | フロントエンド、エッジコンピューティング |

---

## 6. 禁止事項

* **副作用の導入**: 現バージョンの Mumei は純粋関数的な検証を主眼としているため、グローバル変数の操作や未定義の外部 I/O を `body` 内に記述することを禁ずる。
* **型変換の無視**: 数値は原則として `i64` (Int64) として扱い、オーバーフローの可能性を常に考慮せよ。

---

## 7. メソッド比較

Mumeiは、LeanやCoqのような重厚な定理証明支援系と、現代的なアプリケーション開発の架け橋となるべく設計されています。

| 比較項目 | Lean 4 | Coq / Rocq | Mumei (無銘) |
|----------|--------|------------|--------------|
| 主な用途 | 数学全般の証明、ソフトウェア検証 | 数学的定理の証明、高信頼システム | AIエージェントによる安全なコード生成 |
| 難易度 | 非常に高い（タクティックの習得が必要） | 非常に高い（数学的背景が必須） | 中（通常のプログラミングに近い） |
| 検証エンジン | 独自のカーネル / Lean Checker | Coq Kernel | Z3 SMT Solver (自動証明重視) |
| 検証の自動化 | 一部自動（Aesop等）だが手動が主 | 手動（Ltac等）による証明記述が主 | 全自動 (requires/ensuresに基づく) |
| 出力ターゲット | Lean実行環境、C | OCaml, Haskell, Scheme等へ抽出 | LLVM IR, Rust, Go, TypeScript |
| AI親和性 | 研究段階（LLMによるタクティック生成） | 研究段階 | ネイティブ (JSONレポート/自律修正前提) |
| 設計思想 | 数学をコードで表現する | 証明をプログラムとして構築する | 仕様を満たさないコードを「鍛造」させない |

---
