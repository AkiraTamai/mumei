Here is the English version of your `instruction.md`. It has been translated to maintain the authoritative, "blacksmithing-inspired" tone of the Mumei project.

---

# ðŸ“œ instruction.md

## 1. Role and Purpose of Mumei

Mumei is a protocol designed to transform the uncertain code generated by AI agents (the result of "probabilistic inference") into verified, reliable assets.
Developers and AI agents must define **Immutable Truths (requires/ensures)** before writing any algorithmic logic.

---

## 2. Syntactic Rules

### 2.1 Basic Structure of an Atom

All logic must be encapsulated within an `atom`.

* **requires**: Conditions that must be satisfied *before* execution.
* **ensures**: Outcomes that are guaranteed *after* execution.
* **body**: The implementation of the algorithm. Using `{}` block syntax and `let` variable bindings is highly recommended.

### 2.2 Ironclad Rules for Control Flow

* **if-else**: An `else` block must always be included to ensure mathematical totality (exhaustiveness).
* **let**: Variables must be treated as **immutable**. Re-assignment is not permitted.
* **Block Evaluation**: The final expression in a block `{ ... }` is treated as the return value of that block.

---

## 3. Forging Guidelines

### 3.1 Absolute Elimination of Division by Zero

When performing division, you must either explicitly state in the `requires` clause that the divisor is non-zero or implement a dynamic guard using an `if` statement.

> **Bad**: `body: a / b;`
> **Good**: `body: if b != 0 { a / b } else { 0 };`

### 3.2 Leveraging Quantifiers

When handling arrays or ranges, use `forall` to define boundary conditions.

*Example*: `requires: forall(i, 0, len, arr[i] > 0);`

---

## 4. Self-Healing Protocol (Handling Verification Failure)

If verification is marked as `Failed`, the developer or AI agent should follow these steps:

1. **Analyze the Counter-example**: Refer to the Visualizer or `report.json` to identify which input values caused the logic to fail.
2. **Strengthen Requirements (`requires`)**: Re-evaluate if the input constraints are too loose.
3. **Repair the Body**: Add `if` guards or implement proper edge-case handling.
4. **Re-forge**: Run `cargo run` again to confirm that the mathematical contradiction has been resolved.

---

## 5. Output Semantics

Understand the following characteristics of the code exported by Mumei:

| Language | Characteristics | Primary Use Case |
| --- | --- | --- |
| **LLVM IR** | Fast, Native Execution | Performance-critical core logic |
| **Rust** | Ownership & Type Safety | Integration into high-reliability systems |
| **Go** | Simplicity & Concurrency | Microservices and Backend systems |
| **TypeScript** | Flexible & Web-Friendly | Frontend and Edge computing |

---

## 6. Numeric Safety

* **Optimization for i64**: The current verification engine is optimized for `i64` (Int64).
* **Overflow Responsibility**: If there is a risk of overflow in arithmetic operations, limit the value range in the `requires` clause. *Note: In future updates, boundary checking will be automated, making these explicit constraints unnecessary.*
* **Precision Alternatives**: Until floating-point support is implemented, using a "fixed-point" approach (e.g., multiplying by 1000 and treating as an integer) is recommended. Once `f64` support is added, rigorous verification including rounding errors will be possible.

---

## 7. Prohibited Actions

* **Introducing Side Effects**: Mumei focuses on pure functional verification. Modifying global variables or performing undefined external I/O within the `body` is strictly prohibited.
* **Ignoring Type Constraints**: Treat numbers as `i64` by default and always account for potential overflows.

---

## 8. Comparison of Methods

Mumei serves as a bridge between heavyweight formal proof assistants and modern application development.

| Item | Lean 4 | Coq / Rocq | Mumei (ç„¡éŠ˜) |
| --- | --- | --- | --- |
| **Primary Use** | General math proofs, SW verification | Mathematical theorems, high-trust systems | **Secure code generation for AI agents** |
| **Difficulty** | Very High (Requires learning tactics) | Very High (Requires math background) | **Moderate (Close to standard coding)** |
| **Verif. Engine** | Custom Kernel / Lean Checker | Coq Kernel | **Z3 SMT Solver (Automated priority)** |
| **Automation** | Partially automated, mainly manual | Mainly manual (via Ltac, etc.) | **Fully Automated (requires/ensures)** |
| **Target Output** | Lean runtime, C | OCaml, Haskell, Scheme, etc. | **LLVM IR, Rust, Go, TypeScript** |
| **AI Synergy** | Research stage (LLM tactics) | Research stage | **Native (JSON reports / Self-healing)** |
| **Design Logic** | Expressing math through code | Building proofs as programs | **Preventing "unforged" (unsafe) code** |

---
