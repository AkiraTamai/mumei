# 📜 instruction.md

## 1. Mumei の役割と存在意義

Mumeiは、AIエージェントが「推論」の結果として出力する不確かなコードを、数学的に「検証済み」の確実な資産へと変換するためのプロトコルである。
開発者は、ロジックを書く前に**不変の真理（requires/ensures）**を定義しなければならない。

---

## 2. 構文規則 (Syntactic Rules)

### 2.1 Atom の基本構造

すべてのロジックは `atom` 単位で記述する。

* **requires**: 実行前に満たされるべき条件。
* **ensures**: 実行後に保証されるべき結果。
* **body**: アルゴリズムの実装。`{}` によるブロック構文と `let` による変数定義を推奨する。

### 2.2 制御構文の鉄則

* **if-else**: 必ず `else` ブロックを含めること（数学的全域性の確保）。
* **let**: 変数は再代入不可（イミュータブル）として扱うこと。
* **ブロック末尾**: ブロック `{ ... }` の最後の式がそのブロックの評価値となる。

---

## 3. 鍛造ガイドライン (Forging Guidelines)

### 3.1 ゼロ除算の徹底排除

除算を行う場合は、必ず `requires` で分母が非ゼロであることを明示するか、`if` 文による動的なガードを実装せよ。

> **Bad**: `body: a / b;`
> **Good**: `body: if b != 0 { a / b } else { 0 };`

### 3.2 量子化子の活用

配列や範囲を扱う際は、`forall`（すべての要素が〜）を用いて境界条件を定義せよ。
例: `requires: forall(i, 0, len, arr[i] > 0);`

---

## 4. 検証失敗時の振る舞い (Self-Healing Protocol)

検証が `Failed` となった場合、開発者（またはAIエージェント）は以下の手順を踏むこと。

1. **反例 (Counter-example) の確認**: ビジュアライザーまたは `report.json` を参照し、どの入力値で論理が破綻したかを特定する。
2. **requires の強化**: 入力値の制約が緩すぎないか検討する。
3. **body の修正**: `if` ガードの追加や、エッジケースの処理を実装する。
4. **再鍛造**: 修正後、再び `cargo run` を実行し、数学的な矛盾が解消されたか確認する。

---

## 5. 言語出力の特性 (Output Semantics)

Mumei から出力されたコードは以下の特性を持つことを理解して利用すること。

| 言語 | 特徴 | 用途 |
| --- | --- | --- |
| **LLVM IR** | 高速・ネイティブ実行 | パフォーマンス重視のコアロジック |
| **Rust** | 所有権・型安全 | 高信頼性システムへの統合 |
| **Go** | シンプル・並行性 | マイクロサービス、バックエンド |
| **TypeScript** | 柔軟・Web親和性 | フロントエンド、エッジコンピューティング |

---

## 6. 禁止事項

* **副作用の導入**: 現バージョンの Mumei は純粋関数的な検証を主眼としているため、グローバル変数の操作や未定義の外部 I/O を `body` 内に記述することを禁ずる。
* **型変換の無視**: 数値は原則として `i64` (Int64) として扱い、オーバーフローの可能性を常に考慮せよ。

---
